/* eslint-disable no-console */
import {readFile, writeFile} from 'node:fs/promises';
import {EOL} from 'node:os';
import {findRoot} from './findRoot.js';
import {parse} from 'semver';
import {stringify} from './stringify.js';
import {version} from '../package.js';

const PREAMBLE = `\
// Generated by package-extract v${version}
// Do not modify by hand.

`;

/**
 * @typedef {Object} ExtractOpts packageExtract options
 * @property {boolean} [commonJS=false] Create a commonJS file instead of ESM
 * @property {boolean} [double=false] True for double quotes, otherwise single
 *   quotes
 * @property {number} [indent=2] Number of spaces to indent. <0 for tabs. 0
 *   for no newlines.
 * @property {(string) => void} [log=console.log] How to log to stdout.
 * @property {string|URL} [output="package.js"] Filename for output, or "-"
 *   for stdout.
 * @property {string} [package="package.json"] Package file to extract from,
 *   found from cwd, searching up
 * @property {string} [regex] If given, regular expression to replace instead
 *   of regenerating output.  Regex should have named matching group to
 *   replace, where the matching group name is the desired field.
 * @property {boolean} [semi=false] Add semicolons to the end of each
 *   variable.
 * @property {string} [startDir=process.cwd()] Which directory to start the
 *   search from.
 * @property {boolean} [trailing=false] Add trailing commas for objects or
 *   arrays?
 * @property {boolean} [types=false] Attempt to add typescript type comments
 *   to extracted items.
 * @property {boolean} [unlessPreRelease=false] Only perform the action if
 * this is not a pre-release
 */

/**
 * @typedef {Required<ExtractOpts>} RequiredExtractOpts
 */

/**
 * Extract one or more fields from a JSON file.
 * @param {ExtractOpts} options
 * @param {string[]} [fields=['version']]
 */
export async function packageExtract(options = {}, fields = ['version']) {
  /** @type {RequiredExtractOpts} */
  const opts = {
    commonJS: false,
    double: false,
    indent: 2,
    output: 'package.js',
    log: console.log,
    package: 'package.json',
    regex: undefined,
    semi: false,
    startDir: process.cwd(),
    trailing: false,
    types: false,
    unlessPreRelease: false,
    ...options,
  };
  if (!fields?.length) {
    fields = ['version'];
  }
  const strOpts = {
    trailing: opts.trailing,
    indent: opts.indent < 0 ? '\t'.repeat(-opts.indent) : ' '.repeat(opts.indent),
    quote: opts.double ? '"' : '\'',
    newline: opts.indent === 0 ? '' : EOL,
  };

  const semi = opts.semi ? ';' : '';
  const pkg = await findRoot(process.cwd(), opts.package);
  const props = JSON.parse(await readFile(pkg, 'utf8'));
  let out = PREAMBLE;

  if (opts.unlessPreRelease) {
    const ver = parse(props.version);
    if (!ver) {
      throw new Error(`Invalid semver version: "${props.version}".`);
    }
    if (ver.prerelease.length) {
      return;
    }
  }

  if (opts.regex) {
    const re = new RegExp(opts.regex, 'g');
    const orig = await readFile(opts.output, 'utf8');
    // @ts-ignore
    const updated = orig.replace(re, (m, ...args) => {
      const groups = args[args.length - 1];
      for (const [k, v] of Object.entries(groups)) {
        if (v && props[k]) {
          return props[k];
        }
      }
      return m;
    });
    out = updated;
  } else {
    if (opts.commonJS) {
      out += `${stringify('use strict', strOpts)}${semi}\n\n`;
    }
    for (const field of fields) {
      if (!Object.prototype.hasOwnProperty.call(props, field)) {
        throw new Error(`Property "${field}" not found in "${pkg}"`);
      }
      if (opts.commonJS) {
        out += 'exports.';
      } else {
        out += 'export const ';
      }
      out += `${field} = ${stringify(props[field], strOpts)}${semi}\n`;
    }
  }

  if (opts.output === '-') {
    opts.log(out);
  } else {
    await writeFile(opts.output, out, 'utf8');
  }
}
