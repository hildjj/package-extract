import {readFile, unlink, writeFile} from 'node:fs/promises';
import {fileURLToPath} from 'node:url';
import {packageExtract} from '../lib/index.js';
import path from 'node:path';
import test from 'ava';
import {version} from '../package.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

test('packageExtract', async t => {
  let out = null;
  const opts = {
    log(str) {
      out = str;
    },
    output: '-',
  };
  await packageExtract(opts, ['name', 'homepage']);
  t.is(out, `\
// Generated by package-extract v${version}
// Do not modify by hand.

export const name = 'package-extract'
export const homepage = 'https://github.com/hildjj/package-extract'
`);
  out = null;
  await packageExtract(opts, []);
  t.is(out, `\
// Generated by package-extract v${version}
// Do not modify by hand.

export const version = '${version}'
`);
  out = null;
  await t.throwsAsync(() => packageExtract(opts, ['field does not exist']));
  t.is(out, null);

  const output = path.join(__dirname, 'testOutput.js');
  await packageExtract({...opts, output});
  await unlink(output);
});

test('commonJS', async t => {
  let out = null;
  const opts = {
    log(str) {
      out = str;
    },
    output: '-',
    commonJS: true,
  };
  await packageExtract(opts, []);
  t.is(out, `\
// Generated by package-extract v${version}
// Do not modify by hand.

'use strict'

exports.version = '${version}'
`);
});

test('indent tab', async t => {
  let out = null;
  const opts = {
    log(str) {
      out = str;
    },
    output: '-',
    indent: -1,
    double: true,
  };
  await packageExtract(opts, ['engines']);
  t.regex(out, /engines/);
});

test('indent zero', async t => {
  let out = null;
  const opts = {
    log(str) {
      out = str;
    },
    output: '-',
    indent: 0,
    semi: true,
  };
  await packageExtract(opts, ['keywords']);
  t.regex(out, /keywords/);
});

test('regex', async t => {
  const output = new URL('./fixtures/index.html', import.meta.url);
  const orig = await readFile(output, 'utf8');
  await packageExtract({
    output,
    regex: '(?<=https:\\/\\/unpkg.com\\/peggy@)(?<version>\\d+\\.\\d+\\.\\d+)(?=\\/browser\\/peggy\\.min\\.js)',
  });
  let mod = await readFile(output, 'utf8');
  t.regex(mod, new RegExp(version.replace(/\./g, '\\.')));

  await packageExtract({
    output,
    regex: '(?<=https:\\/\\/unpkg.com\\/peggy@)(?<__UNKNOWN_FIELD__>\\d+\\.\\d+\\.\\d+)(?=\\/browser\\/peggy\\.min\\.js)',
  });
  mod = await readFile(output, 'utf8');
  t.regex(mod, new RegExp(version.replace(/\./g, '\\.')));

  await writeFile(output, orig);
});

test('unlessPreRelease', async t => {
  let out = '';
  const opts = {
    log(str) {
      out += str;
    },
    package: path.join(__dirname, 'fixtures', 'prerelease.json'),
    unlessPreRelease: true,
  };

  await packageExtract(opts);
  t.is(out, '');
});

test('unlessPreRelease invalid', async t => {
  let out = '';
  const opts = {
    log(str) {
      out += str;
    },
    package: path.join(__dirname, 'fixtures', 'invalidVersion.json'),
    unlessPreRelease: true,
  };

  await t.throwsAsync(() => packageExtract(opts));
  t.is(out, '');
});
